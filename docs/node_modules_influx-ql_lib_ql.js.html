<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>node_modules/influx-ql/lib/ql.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Client.html">Client</a><ul class='methods'><li data-type='method'><a href="Client.html#createDatabase">createDatabase</a></li><li data-type='method'><a href="Client.html#createRetentionPolicy">createRetentionPolicy</a></li><li data-type='method'><a href="Client.html#dropDatabase">dropDatabase</a></li><li data-type='method'><a href="Client.html#dropRetentionPolicy">dropRetentionPolicy</a></li><li data-type='method'><a href="Client.html#on">on</a></li><li data-type='method'><a href="Client.html#query">query</a></li><li data-type='method'><a href="Client.html#queryPost">queryPost</a></li><li data-type='method'><a href="Client.html#queryRaw">queryRaw</a></li><li data-type='method'><a href="Client.html#schema">schema</a></li><li data-type='method'><a href="Client.html#showDatabases">showDatabases</a></li><li data-type='method'><a href="Client.html#showFieldKeys">showFieldKeys</a></li><li data-type='method'><a href="Client.html#showMeasurements">showMeasurements</a></li><li data-type='method'><a href="Client.html#showRetentionPolicies">showRetentionPolicies</a></li><li data-type='method'><a href="Client.html#showTagKeys">showTagKeys</a></li><li data-type='method'><a href="Client.html#startHealthCheck">startHealthCheck</a></li><li data-type='method'><a href="Client.html#stopHealthCheck">stopHealthCheck</a></li><li data-type='method'><a href="Client.html#syncQuery">syncQuery</a></li><li data-type='method'><a href="Client.html#syncWrite">syncWrite</a></li><li data-type='method'><a href="Client.html#updateRetentionPolicy">updateRetentionPolicy</a></li><li data-type='method'><a href="Client.html#write">write</a></li><li data-type='method'><a href="Client.html#writePoint">writePoint</a></li></ul></li><li><a href="QL.html">QL</a><ul class='methods'><li data-type='method'><a href="QL.html#addField">addField</a></li><li data-type='method'><a href="QL.html#addFunction">addFunction</a></li><li data-type='method'><a href="QL.html#addGroup">addGroup</a></li><li data-type='method'><a href="QL.html#condition">condition</a></li><li data-type='method'><a href="QL.html#emptyConditions">emptyConditions</a></li><li data-type='method'><a href="QL.html#emptyFields">emptyFields</a></li><li data-type='method'><a href="QL.html#emptyFunctions">emptyFunctions</a></li><li data-type='method'><a href="QL.html#emptyGroups">emptyGroups</a></li><li data-type='method'><a href="QL.html#removeField">removeField</a></li><li data-type='method'><a href="QL.html#removeFunction">removeFunction</a></li><li data-type='method'><a href="QL.html#removeGroup">removeGroup</a></li><li data-type='method'><a href="QL.html#toSelect">toSelect</a></li></ul></li><li><a href="Reader.html">Reader</a><ul class='methods'><li data-type='method'><a href="Reader.html#addCalculate">addCalculate</a></li><li data-type='method'><a href="Reader.html#addField">addField</a></li><li data-type='method'><a href="Reader.html#addFunction">addFunction</a></li><li data-type='method'><a href="Reader.html#addGroup">addGroup</a></li><li data-type='method'><a href="Reader.html#condition">condition</a></li><li data-type='method'><a href="Reader.html#emptyConditions">emptyConditions</a></li><li data-type='method'><a href="Reader.html#emptyFields">emptyFields</a></li><li data-type='method'><a href="Reader.html#emptyFunctions">emptyFunctions</a></li><li data-type='method'><a href="Reader.html#emptyGroups">emptyGroups</a></li><li data-type='method'><a href="Reader.html#get">get</a></li><li data-type='method'><a href="Reader.html#queue">queue</a></li><li data-type='method'><a href="Reader.html#removeField">removeField</a></li><li data-type='method'><a href="Reader.html#removeFunction">removeFunction</a></li><li data-type='method'><a href="Reader.html#removeGroup">removeGroup</a></li><li data-type='method'><a href="Reader.html#set">set</a></li><li data-type='method'><a href="Reader.html#then">then</a></li><li data-type='method'><a href="Reader.html#toSelect">toSelect</a></li><li data-type='method'><a href="Reader.html#toString">toString</a></li></ul></li><li><a href="Writer.html">Writer</a><ul class='methods'><li data-type='method'><a href="Writer.html#field">field</a></li><li data-type='method'><a href="Writer.html#queue">queue</a></li><li data-type='method'><a href="Writer.html#tag">tag</a></li><li data-type='method'><a href="Writer.html#then">then</a></li><li data-type='method'><a href="Writer.html#time">time</a></li><li data-type='method'><a href="Writer.html#toJSON">toJSON</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">node_modules/influx-ql/lib/ql.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const internal = require('./internal');
const util = require('util');

function getParam(args, is, defaultValue) {
  let result;
  args.forEach((v) => {
    if (!util.isUndefined(result)) {
      return;
    }
    if (is(v)) {
      result = v;
    }
  });
  if (util.isUndefined(result)) {
    result = defaultValue;
  }
  return result;
}

function getTimeCondition(time, type) {
  let timeDesc = '';
  if (time.charAt(0) === '-') {
    timeDesc = `now() - ${time.substring(1)}`;
  } else if (/\d{4}-\d{2}-\d{2}/.test(time)) {
    timeDesc = `'${time}'`;
  } else {
    timeDesc = time;
  }
  return `time ${type} ${timeDesc}`;
}

function addToArray(arr, args) {
  /* istanbul ignore else */
  if (args &amp;&amp; args.length) {
    /* eslint prefer-spread:0 */
    arr.push.apply(arr, args);
  }
}

function removeFromArray(arr, args) {
  return arr.filter(item => args.indexOf(item) === -1);
}

function convert(field) {
  const f = field.toLowerCase();
  const digitReg = /^[0-9]/;
  const reg = /[^a-z0-9_]/;
  /* istanbul ignore else */
  if (digitReg.test(f) || reg.test(f)) {
    return `"${field}"`;
  }
  return field;
}

function convertKey(key) {
  if (!util.isString(key)) {
    return key;
  }
  // key + x
  if (key.indexOf('+') !== -1) {
    return key;
  }
  return `"${key}"`;
}

function isRegExp(value) {
  return value.length > 2 &amp;&amp; value.charAt(0) === '/' &amp;&amp; value.charAt(value.length - 1) === '/';
}

function convertConditionValue(value) {
  if (util.isString(value) &amp;&amp; !isRegExp(value)) {
    return `'${value}'`;
  }
  return value;
}

function convertGroupValue(value) {
  const reg = /time\(\S+\)/;
  if (value === '*' || value.match(reg)) {
    return value;
  }
  return `"${value}"`;
}

function convertMeasurement(measurement) {
  if (measurement.charAt(0) === ':' || isRegExp(measurement)) {
    return measurement;
  }
  return `"${measurement}"`;
}

function getRelation(args, defaultValue) {
  let result = '';
  args.forEach((arg) => {
    if (!util.isString(arg)) {
      return;
    }
    const lowArg = arg.toLowerCase();
    if (lowArg === 'and' || lowArg === 'or') {
      result = lowArg;
    }
  });
  return result || defaultValue || 'and';
}

function getOperator(args, defaultValue) {
  let result = '';
  args.forEach((arg) => {
    if (!util.isString(arg)) {
      return;
    }
    const lowArg = arg.toLowerCase();
    if (lowArg !== 'and' &amp;&amp; lowArg !== 'or') {
      result = lowArg;
    }
  });
  return result || defaultValue || '=';
}

function getConditions(data, operator, relation) {
  if (util.isString(data)) {
    const reg = /\sand\s|\sor\s/i;
    if (reg.test(data)) {
      return `(${data})`;
    }
    return data;
  }
  const keys = Object.keys(data);
  const arr = keys.map((k) => {
    const key = convertKey(k);
    const v = data[k];
    if (util.isArray(v)) {
      const tmpArr = v.map(tmp => `${key} ${operator} ${convertConditionValue(tmp)}`);
      return `(${tmpArr.join(' or ')})`;
    }
    const value = convertConditionValue(v);
    return `${key} ${operator} ${value}`;
  });
  if (arr.length > 1) {
    const joinKey = ` ${relation} `;
    return `(${arr.join(joinKey)})`;
  }
  return arr.join('');
}

function getFrom(data) {
  const arr = [];
  if (data.db) {
    arr.push(`"${data.db}"`);
    if (data.rp) {
      arr.push(`"${data.rp}"`);
    }
  }
  if (data.measurement) {
    if (!data.rp &amp;&amp; data.db) {
      arr.push('');
    }
    arr.push(convertMeasurement(data.measurement));
  }
  return `from ${arr.join('.')}`;
}

function getInto(data) {
  const arr = [];
  if (data.intoDB) {
    arr.push(`"${data.intoDB}"`);
    if (data.intoRP) {
      arr.push(`"${data.intoRP}"`);
    } else {
      arr.push('');
    }
  }
  arr.push(convertMeasurement(data.into));
  return `into ${arr.join('.')}`;
}

function getQL(data) {
  const arr = [];
  arr.push(getFrom(data));

  const conditions = data.conditions.slice();
  const groups = data.groups;
  if (data.start) {
    conditions.push(getTimeCondition(data.start, '>='));
  }
  if (data.end) {
    conditions.push(getTimeCondition(data.end, '&lt;='));
  }

  if (conditions.length) {
    const joinKey = ` ${data.relation} `;
    arr.push(`where ${conditions.sort().join(joinKey)}`);
  }

  if (groups &amp;&amp; groups.length) {
    arr.push(`group by ${groups.sort().map(convertGroupValue).join(',')}`);

    if (!util.isNullOrUndefined(data.fill)) {
      arr.push(`fill(${data.fill})`);
    }
  }

  if (data.order) {
    arr.push(`order by time ${data.order}`);
  }

  if (data.limit) {
    arr.push(`limit ${data.limit}`);
  }

  if (data.slimit) {
    arr.push(`slimit ${data.slimit}`);
  }

  if (data.offset) {
    arr.push(`offset ${data.offset}`);
  }

  if (data.soffset) {
    arr.push(`soffset ${data.soffset}`);
  }

  return arr.join(' ');
}

function showKeys(type, measurement) {
  let ql = `show ${type} keys`;
  if (measurement) {
    ql = `${ql} from "${measurement}"`;
  }
  return ql;
}

/**
 * Influx QL
 *
 * @example
 * const QL = require('influx-ql');
 * const ql = new QL('mydb');
 * ql.measurement = 'http';
 * ql.RP = 'two-weeks';
 * ql.addField('status', 'spdy', 'fetch time');
 * ql.start = '2016-01-01';
 * ql.end = '-3h';
 * ql.limit = 10;
 * ql.order = 'desc';
 * ql.offset = 10;
 * ql.addGroup('spdy');
 * ql.condition('code', 400);
 * ql.condition('use', 30, '&lt;=');
 * ql.fill = 0;
 * console.info(ql.toSelect());
 */
class QL {
  constructor(db) {
    const data = internal(this);
    data.fields = [];
    data.conditions = [];
    data.functions = [];
    data.groups = [];
    data.rp = '';
    data.intoRP = '';
    data.db = db;
    data.relation = 'and';
  }

  set database(v) {
    internal(this).db = v;
    return this;
  }

  get database() {
    return internal(this).db;
  }

  set intoDatabase(v) {
    internal(this).intoDB = v;
    return this;
  }

  get intoDatabase() {
    return internal(this).intoDB;
  }

  /**
   * Set influx ql retention policy
   * @param {String} rp - The reten retention policy
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.RP = 'two-weeks';
   * console.info(ql.toSelect());
   * // => select * from "mydb"."two-weeks"."http"
   */
  set RP(rp) {
    internal(this).rp = rp;
  }
  /**
   * Get influx ql retention policy
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.RP = 'two-weeks';
   * console.info(ql.RP);
   * // => two-weeks
   */
  get RP() {
    return internal(this).rp;
  }

  set intoRP(v) {
    internal(this).intoRP = v;
    return this;
  }

  get intoRP() {
    return internal(this).intoRP;
  }

  /**
   * Set influx ql measurement
   * @param  {String} measurement - The measurement's name
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * console.info(ql.toSelect());
   * // => select * from "mydb".."http"
   */
  set measurement(measurement) {
    internal(this).measurement = measurement;
  }

  /**
   * Get influx ql measurement
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * console.info(ql.measurement);
   * // => 'http'
   */
  get measurement() {
    return internal(this).measurement;
  }

  /**
   * Set influx ql start time
   * @param  {String} start - start time
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.start = '-3h';
   * console.info(ql.toSelect());
   * // => select * from "mydb".."http" where time >= now() - 3h
   */
  set start(start) {
    internal(this).start = start;
  }

  /**
   * Get influx ql start time
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.start = '-3h';
   * console.info(ql.start);
   * // => '-3h';
   */
  get start() {
    return internal(this).start;
  }

  /**
   * Set influx ql end time
   * @param  {String} end - end time
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.end = '-1h';
   * console.info(ql.toSelect());
   * // => select * from "mydb".."http" where time &lt;= now() - 1h
   */
  set end(v) {
    internal(this).end = v;
  }

  /**
   * Get influx ql end time
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.end = '-1h';
   * console.info(ql.end);
   * // => '-1h';
   */
  get end() {
    return internal(this).end;
  }

  /**
   * Set influx ql query result point limit
   * @param  {Integer} limit - the result point limit
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.limit = 10;
   * console.info(ql.toSelect());
   * // => select * from "mydb".."http" limit 10
   */
  set limit(limit) {
    internal(this).limit = limit;
  }

  /**
   * Get influx ql query result point limit
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.limit = 10;
   * console.info(ql.limit);
   * // => 10
   */
  get limit() {
    return internal(this).limit;
  }

  /**
   * Set influx query result series limit
   * @param  {Integer} slimit - the result series limit
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.slimit = 3;
   * console.info(ql.toSelect());
   * // => select * from "mydb" slimit 3
   */
  set slimit(slimit) {
    internal(this).slimit = slimit;
    return this;
  }

  /**
   * Get influx query result series limit
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.slimit = 3;
   * console.info(ql.slimit);
   * // => 3
   */
  get slimit() {
    return internal(this).slimit;
  }

  /**
   * Set the influx query result fill value for time intervals that have no data
   * @param  {String | Number} fill - fill value, special value: linear none null previous.
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addGroup('spdy');
   * ql.fill = 0;
   * console.info(ql.toSelect());
   * // => select * from "mydb".."http" group by "spdy" fill(0)
   */
  set fill(fill) {
    internal(this).fill = fill;
  }

  /**
   * Get the influx query result fill value for time intervals that have no data
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addGroup('spdy');
   * ql.fill = 0;
   * console.info(ql.fill);
   * // => 0
   */
  get fill() {
    return internal(this).fill;
  }

  set into(v) {
    internal(this).into = v;
    return this;
  }

  get into() {
    return internal(this).into;
  }

  /**
   * Set the influx query result order of time
   * @param  {String} order - 'desc' or 'asc'
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addGroup('spdy');
   * ql.order = 'desc';
   * console.info(ql.toSelect());
   * // => select * from "mydb".."http" group by "spdy" order by time desc
   */
  set order(order) {
    internal(this).order = order;
  }

  /**
   * Get the influx query result order of time
   * @param  {String} order - 'desc' or 'asc'
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addGroup('spdy');
   * console.info(ql.order);
   * // => undefined
   * ql.order = 'desc';
   * // => 'desc'
   */
  get order() {
    return internal(this).order;
  }

  /**
   * Set influx ql query offset of the result
   * @param  {Integer} offset - offset value
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.offset = 10;
   * console.info(ql.toSelect());
   * // => select * from "mydb".."http" offset 10
   */
  set offset(v) {
    internal(this).offset = v;
  }

  /**
   * Get influx ql query offset of the result
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * console.info(ql.offset);
   * // => 0
   * ql.offset = 10;
   * console.info(ql.offset);
   * // => 10
   */
  get offset() {
    return internal(this).offset || 0;
  }

  /**
   * Set influx ql offset series in the query results
   * @param  {Integer} soffset - soffset value
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.soffset = 10;
   * console.info(ql.toSelect());
   * // => select * from "mydb" soffset 10
   */
  set soffset(soffset) {
    internal(this).soffset = soffset;
  }

  /**
   * Get influx ql offset series in the query results
   * @return {Integer}
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * console.info(ql.soffset);
   * // => 0
   * ql.soffset = 10;
   * console.info(ql.soffset);
   * // => 10
   */
  get soffset() {
    return internal(this).soffset || 0;
  }

  /**
   * Get influx ql default where relation
   * @return {String}
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * console.info(ql.relation);
   * // => 'and'
   */
  get relation() {
    return internal(this).relation;
  }

  /**
   * Set influx ql default where relation
   * @param  {String} relation - the default relation
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * console.info(ql.relation);
   * // => and
   * ql.relation = 'or';
   * console.info(ql.relation);
   * // => or
   */
  set relation(relation) {
    internal(this).relation = relation;
  }

  // CQ BEGIN
  set cqName(v) {
    internal(this).cqName = v;
    return this;
  }

  get cqName() {
    return internal(this).cqName;
  }

  set cqEvery(v) {
    internal(this).cqEvery = v;
    return this;
  }

  get cqEvery() {
    return internal(this).cqEvery;
  }

  set cqFor(v) {
    internal(this).cqFor = v;
    return this;
  }

  get cqFor() {
    return internal(this).cqFor;
  }
  // CQ END

  /**
   * Add the field of the query result
   * @param  {String} field - field's name
   * @return QL
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addField('status', 'spdy', 'fetch time');
   * console.info(ql.toSelect());
   * // => select "fetch time","spdy","status" from "mydb".."http"
   */
  addField() {
    const args = Array.from(arguments);
    addToArray(internal(this).fields, args);
    return this;
  }
  /**
   * Remove the field of the query result
   * @param  {String} field - field's name
   * @return QL
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addField('status', 'spdy', 'fetch time');
   * ql.removeField('status');
   * console.info(ql.toSelect());
   * // => select "fetch time","spdy" from "mydb".."http"
   */
  removeField() {
    const data = internal(this);
    data.fields = removeFromArray(data.fields, Array.from(arguments));
    return this;
  }

  /**
   * Remove all fields of the query result
   * @return QL
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addField('status', 'spdy', 'fetch time');
   * ql.emptyFields();
   * console.info(ql.toSelect());
   * // => select * from "mydb".."http"
   */
  emptyFields() {
    const data = internal(this);
    data.fields.length = 0;
    return this;
  }

  /**
   * Add the influx ql where condition
   * @param  {String} key   - the condition key
   * @param  {String} value - the condition value
   * @param  {String} relation - the multi condition relation
   * @param  {String} operator - the conditon operator, default is '='
   * @return {QL}
   * @since 2.0.0
   * @example
   * const ql = new QL();
   * ql.measurement = 'http';
   * ql.condition({
   *   code: 500,
   *   spdy: '1',
   * });
   * console.info(ql.toSelect());
   * // => select * from "http" where ("code" = 500 and "spdy" = '1')
   * @example
   * const ql = new QL();
   * ql.measurement = 'http';
   * ql.condition('spdy', ['1', '2']);
   * console.info(ql.toSelect());
   * // => select * from "mydb".."http" where ("spdy" = '1' or "spdy" = '2')
   * @example
   * const ql = new QL();
   * ql.measurement = 'http';
   * ql.condition({
   *   code: 500,
   *   spdy: '1',
   * }, '!=');
   * console.info(ql.toSelect());
   * // => select * from "http" where ("code" != 500 and "spdy" != '1')
   */
  condition(key, value, rlt, op) {
    let data = key;
    let args = [rlt, op];
    if (util.isObject(key)) {
      args = [value, rlt];
    } else if (value) {
      data = {};
      data[key] = value;
    }

    const relation = getRelation(args);
    const operator = getOperator(args);

    const condition = getConditions(data, operator, relation);
    addToArray(internal(this).conditions, [condition]);
    return this;
  }

  /**
   * Empty the influx ql where condition
   * @return {QL}
   * @since 2.0.0
   * @example
   * const ql = new QL();
   * ql.measurement = 'http';
   * ql.condition({
   *   code: 500,
   *   spyd: '1',
   * });
   * console.info(ql.toSelect());
   * // => select * from "http" where ("code" = 500 and "spdy" = '1')
   * ql.emptyConditions();
   * console.info(ql.toSelect());
   * // => select * from "http"
   */
  emptyConditions() {
    internal(this).conditions.length = 0;
    return this;
  }

  /**
   * Add influx ql function
   * @param {String} type  - function name
   * @param {Any} field - function param
   * @param {Any} field - function param
   * @return {QL}
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addFunction('count', 'use');
   * ql.addFunction('mean', 'use');
   * ql.addGroup('spdy');
   * console.info(ql.toSelect());
   * // => select count("use"),mean("use") from "mydb".."http" group by "spdy"
   * @example
   * // version 2.0.1
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addFunction("bottom", 'use', 3);
   * console.info(ql.toSelect());
   * // => select bottom("use",3) from "mydb".."http"
   * * @example
   * // version 2.0.3
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addFunction('count("use")');
   * console.info(ql.toSelect());
   * // => select count("use") from "mydb".."http"
   */
  addFunction() {
    const args = Array.from(arguments);
    const functions = internal(this).functions;
    if (args.length >= 2) {
      const type = args.shift();
      const arr = args.map(convertKey);
      functions.push(`${type}(${arr.join(',')})`);
    } else {
      functions.push(args[0]);
    }
    return this;
  }

  /**
   * Remove influx ql function
   * @param {String} type  - function name
   * @param {Any} field - function param
   * @return {QL}
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addFunction('count', 'use');
   * ql.addFunction('mean', 'use');
   * ql.removeFunction('count', 'use');
   * ql.addGroup('spdy');
   * console.info(ql.toSelect());
   * // => select mean("use") from "mydb".."http" group by "spdy"
   */
  removeFunction(type, field) {
    if (type &amp;&amp; field) {
      const data = internal(this);
      data.functions = removeFromArray(data.functions, `${type}(${convertKey(field)})`);
    }
    return this;
  }

  /**
   * Remove all influx ql functions
   * @return {QL}
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addFunction('count', 'use');
   * ql.addFunction('mean', 'use');
   * ql.emptyFunctions();
   * ql.addGroup('spdy');
   * console.info(ql.toSelect());
   * // => select * from "mydb".."http" group by "spdy"
   */
  emptyFunctions() {
    internal(this).functions.length = 0;
    return this;
  }

  /**
   * Add influx ql group by
   * @param {String} tag - tag's name
   * @return {QL}
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addGroup('spdy', 'method');
   * ql.addFunction('count', 'use');
   * console.info(ql.toSelect());
   * // => select count("use") from "mydb".."http" group by "method","spdy"
   */
  addGroup() {
    const args = Array.from(arguments);
    addToArray(internal(this).groups, args);
    return this;
  }

  /**
   * Remove influx ql group by
   * @param {String} tag - tag's name
   * @return {QL}
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addGroup('spdy', 'method');
   * ql.removeGroup('spdy')
   * ql.addFunction('count', 'use');
   * console.info(ql.toSelect());
   * // => select count("use") from "mydb".."http" group by "method"
   */
  removeGroup() {
    const args = Array.from(arguments);
    const data = internal(this);
    data.groups = removeFromArray(data.groups, args);
    return this;
  }

  /**
   * Empty influx ql group by
   * @return {QL}
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.addGroup('spdy', 'method');
   * ql.emptyGroups();
   * console.info(ql.toSelect());
   * // => select * from "mydb".."http"
   */
  emptyGroups() {
    const data = internal(this);
    data.groups.length = 0;
    return this;
  }

  /**
   * Get the influx select ql
   * @return {String}
   * @since 2.0.0
   * @example
   * const ql = new QL('mydb');
   * ql.measurement = 'http';
   * ql.RP = 'two-weeks';
   * ql.addField('status', 'spdy', 'fetch time');
   * ql.start = '2016-01-01';
   * ql.end = '-3h';
   * ql.limit = 10;
   * ql.order = 'desc';
   * ql.offset = 10;
   * ql.addGroup('spdy');
   * ql.condition('code', 400);
   * ql.condition('use', 30, '&lt;=');
   * ql.fill = 0;
   * console.info(ql.toSelect());
   */
  toSelect() {
    const data = internal(this);
    const arr = ['select'];
    const fields = data.fields;
    const functions = data.functions;
    const selectFields = [];
    if (functions &amp;&amp; functions.length) {
      functions.sort().forEach(item => selectFields.push(item));
    }
    if (fields &amp;&amp; fields.length) {
      fields.sort().map(convertKey).forEach(item => selectFields.push(item));
    }
    if (selectFields.length) {
      arr.push(selectFields.join(','));
    } else {
      arr.push('*');
    }

    if (data.into) {
      arr.push(getInto(data));
    }

    arr.push(getQL(data));

    return arr.join(' ');
  }

  toCQ() {
    const data = internal(this);
    const arr = [`create continuous query ${convert(data.cqName)} on "${data.db}"`];

    if (data.cqEvery || data.cqFor) {
      arr.push('resample');
      if (data.cqEvery) {
        arr.push(`every ${data.cqEvery}`);
      }
      if (data.cqFor) {
        arr.push(`for ${data.cqFor}`);
      }
    }

    arr.push(`begin ${this.toSelect()} end`);

    return arr.join(' ');
  }

  static createDatabase(db) {
    return `create database ${convert(db)}`;
  }

  static createDatabaseNotExists(db) {
    return `create database if not exists ${convert(db)}`;
  }

  static dropDatabase(db) {
    return `drop database ${convert(db)}`;
  }

  static showDatabases() {
    return 'show databases';
  }

  static showRetentionPolicies(db) {
    return `show retention policies on ${convert(db)}`;
  }

  static showMeasurements() {
    return 'show measurements';
  }

  static showTagKeys(measurement) {
    return showKeys('tag', measurement);
  }

  static showFieldKeys(measurement) {
    return showKeys('field', measurement);
  }

  static showSeries(measurement) {
    let ql = 'show series';
    if (measurement) {
      ql = `${ql} from "${measurement}"`;
    }
    return ql;
  }

  static createRP(name, database, duration, replication, shardDuration, isDefault) {
    if (!name || !database || !duration) {
      throw new Error('name, database and duration can not be null');
    }
    const args = [replication, shardDuration, isDefault];
    const defaultValue = getParam(args, util.isBoolean);
    const rpl = getParam(args, util.isNumber, 1);
    const shdDuration = getParam(args, util.isString);
    const arr = [`create retention policy "${name}" on "${database}"`];
    if (duration) {
      arr.push(`duration ${duration}`);
    }
    if (rpl) {
      arr.push(`replication ${rpl}`);
    }
    if (shdDuration) {
      arr.push(`shard duration ${shdDuration}`);
    }
    if (defaultValue) {
      arr.push('default');
    }
    return arr.join(' ');
  }

  static dropRP(name, database) {
    return `drop retention policy "${name}" on "${database}"`;
  }

  static updateRP(name, database, duration, replication, shardDuration, isDefault) {
    if (!name || !database) {
      throw new Error('name and database can not be null');
    }
    const args = [replication, shardDuration, isDefault];
    const defaultValue = getParam(args, util.isBoolean);
    const rpl = getParam(args, util.isNumber);
    const shdDuration = getParam(args, util.isString);
    const arr = [`alter retention policy "${name}" on "${database}"`];
    if (duration &amp;&amp; duration !== '0') {
      arr.push(`duration ${duration}`);
    }
    if (rpl) {
      arr.push(`replication ${rpl}`);
    }
    if (shdDuration) {
      arr.push(`shard duration ${shdDuration}`);
    }
    if (defaultValue) {
      arr.push('default');
    }
    return arr.join(' ');
  }
}

module.exports = QL;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sun Jan 22 2017 14:27:28 GMT+0800 (CST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
